package main

import (
	"bytes"
	"encoding/json"
	"testing"
	"unsafe"

	"github.com/govm-net/vm/mock"
)

// 模拟宿主函数的全局变量
var (
	// 模拟主机缓冲区
	mockHostBuffer []byte = make([]byte, HostBufferSize)

	// 记录最后一次调用的宿主函数ID和参数
	lastHostFuncID   int32
	lastHostArgPtr   int32
	lastHostArgLen   int32
	lastHostRetValue int64

	// 模拟状态数据
	mockSender         = [20]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
	mockContractAddr   = [20]byte{20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
	mockBlockHeight    = int64(12345)
	mockBlockTime      = int64(1647312000)
	mockBalance        = uint64(1000000)
	mockObjectID       = [32]byte{1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8}
	mockObjectOwner    = [20]byte{5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9}
	mockContractResult = []byte(`{"result": "success"}`)
)

// 测试用读取内存的帮助函数
func testReadMemory(ptr int32, length int32) []byte {
	if ptr == 0 || length == 0 {
		return nil
	}

	data := make([]byte, length)
	src := unsafe.Pointer(uintptr(ptr))
	copy(data, (*[1 << 30]byte)(src)[:length:length])
	return data
}

// 设置测试环境
func setupTestEnvironment() {
	// 初始化主机缓冲区
	hostBufferPtr = int32(uintptr(unsafe.Pointer(&mockHostBuffer[0])))
}

// 为测试添加一个可被测试使用的宿主函数实现
// 这些实现在mock_host_functions_test.go中提供

// 覆盖contract.go中的同名函数，提供测试实现
// call_host_set 的测试实现
func call_host_set(funcID, argPtr, argLen int32) int64 {
	// 记录调用
	lastHostFuncID = funcID
	lastHostArgPtr = argPtr
	lastHostArgLen = argLen

	// 模拟不同函数的行为
	switch funcID {
	case FuncTransfer:
		// 模拟转账成功
		return 0
	case FuncDeleteObject:
		// 模拟删除对象成功
		return 0
	case FuncSetObjectOwner:
		// 模拟设置所有者成功
		return 0
	case FuncSetObjectField:
		// 模拟设置字段成功
		return 0
	case FuncLog:
		// 模拟日志记录成功
		return 0
	default:
		// 其他函数默认成功
		return 1
	}
}

// call_host_get_buffer 的测试实现
func call_host_get_buffer(funcID, argPtr, argLen int32) int32 {
	// 记录调用
	lastHostFuncID = funcID
	lastHostArgPtr = argPtr
	lastHostArgLen = argLen

	// 读取参数数据（如果有）
	var argData []byte
	if argPtr != 0 && argLen > 0 {
		argData = testReadMemory(argPtr, argLen)
	}

	// 模拟不同函数的行为
	switch funcID {
	case FuncGetSender:
		// 写入发送者地址到缓冲区
		copy(mockHostBuffer, mockSender[:])
		return int32(len(mockSender))

	case FuncGetContractAddress:
		// 写入合约地址到缓冲区
		copy(mockHostBuffer, mockContractAddr[:])
		return int32(len(mockContractAddr))

	case FuncGetObject:
		// 确保参数是对象ID
		if len(argData) == len(mockObjectID) {
			// 写入对象ID到缓冲区，表示找到对象
			copy(mockHostBuffer, mockObjectID[:])
			return int32(len(mockObjectID))
		}
		return 0 // 没有找到对象

	case FuncGetObjectWithOwner:
		// 确保参数是地址
		if len(argData) == len(mockSender) {
			// 写入对象ID到缓冲区，表示找到对象
			copy(mockHostBuffer, mockObjectID[:])
			return int32(len(mockObjectID))
		}
		return 0 // 没有找到对象

	case FuncCreateObject:
		// 写入新对象ID到缓冲区
		copy(mockHostBuffer, mockObjectID[:])
		return int32(len(mockObjectID))

	case FuncGetObjectOwner:
		// 确保参数是对象ID
		if len(argData) == len(mockObjectID) {
			// 写入所有者地址到缓冲区
			copy(mockHostBuffer, mockObjectOwner[:])
			return int32(len(mockObjectOwner))
		}
		return 0 // 没有找到所有者

	case FuncGetObjectField:
		// 模拟字段值
		fieldValue := []byte(`{"value": 123}`)
		copy(mockHostBuffer, fieldValue)
		return int32(len(fieldValue))

	case FuncCall:
		// 模拟合约调用结果
		copy(mockHostBuffer, mockContractResult)
		return int32(len(mockContractResult))

	default:
		// 其他函数返回空
		return 0
	}
}

// get_block_height 的测试实现
func get_block_height() int64 {
	return mockBlockHeight
}

// get_block_time 的测试实现
func get_block_time() int64 {
	return mockBlockTime
}

// get_balance 的测试实现
func get_balance(addrPtr int32) uint64 {
	// 不检查地址，总是返回相同的余额
	return mockBalance
}

// 测试单个主机函数: get_block_height
func TestHostFunction_GetBlockHeight(t *testing.T) {
	// 设置测试环境
	setupTestEnvironment()

	// 创建上下文
	ctx := &Context{}

	// 直接调用接口方法，内部会调用host函数
	blockHeight := ctx.BlockHeight()

	// 验证结果是否符合预期
	if blockHeight != uint64(mockBlockHeight) {
		t.Fatalf("Expected block height %d but got %d", mockBlockHeight, blockHeight)
	}
}

// 测试单个主机函数: call_host_set (以Transfer为例)
func TestHostFunction_CallHostSet_Transfer(t *testing.T) {
	// 设置测试环境
	setupTestEnvironment()

	// 创建上下文
	ctx := &Context{}

	// 目标地址和金额
	targetAddr := mockObjectOwner
	amount := uint64(100)

	// 调用Transfer方法，内部会调用call_host_set
	err := ctx.Transfer(targetAddr, amount)

	// 验证没有错误发生
	if err != nil {
		t.Fatalf("Transfer failed with error: %v", err)
	}

	// 验证是否调用了正确的函数ID
	if lastHostFuncID != FuncTransfer {
		t.Fatalf("Expected FuncTransfer (%d) but got %d", FuncTransfer, lastHostFuncID)
	}

	// 验证参数长度是否正确 (预期是20字节地址+8字节金额=28字节)
	if lastHostArgLen != 28 {
		t.Fatalf("Expected 28 bytes of argument data but got %d", lastHostArgLen)
	}
}

// 测试单个主机函数: call_host_get_buffer (以GetSender为例)
func TestHostFunction_CallHostGetBuffer_GetSender(t *testing.T) {
	// 设置测试环境
	setupTestEnvironment()

	// 创建上下文
	ctx := &Context{}

	// 调用Sender方法，内部会调用call_host_get_buffer
	sender := ctx.Sender()

	// 验证返回的地址是否符合预期
	if !bytes.Equal(sender[:], mockSender[:]) {
		t.Fatalf("Expected sender %v but got %v", mockSender, sender)
	}

	// 验证是否调用了正确的函数ID
	if lastHostFuncID != FuncGetSender {
		t.Fatalf("Expected FuncGetSender (%d) but got %d", FuncGetSender, lastHostFuncID)
	}
}

// 测试注册合约函数
func TestRegisterContractFunction(t *testing.T) {
	// 保存原始函数表
	oldFunctions := contractFunctions
	contractFunctions = make(map[string]ContractFunctionHandler)
	defer func() { contractFunctions = oldFunctions }()

	// 创建测试函数
	testFuncName := "TestFunction"
	testFunc := func(ctx *Context, params []byte) (interface{}, error) {
		return "success", nil
	}

	// 注册函数
	registerContractFunction(testFuncName, testFunc)

	// 验证注册是否成功
	if fn, exists := contractFunctions[testFuncName]; !exists {
		t.Fatalf("Function %s was not registered", testFuncName)
	} else if fn == nil {
		t.Fatal("Registered function is nil")
	}
}

// 测试执行结果结构
func TestExecutionResult(t *testing.T) {
	// 测试成功的执行结果
	successResult := ExecutionResult{
		Success: true,
		Data:    "test data",
	}

	// 序列化结果
	successJSON, err := json.Marshal(successResult)
	if err != nil {
		t.Fatalf("Failed to marshal success result: %v", err)
	}

	// 验证序列化结果
	var decoded ExecutionResult
	if err := json.Unmarshal(successJSON, &decoded); err != nil {
		t.Fatalf("Failed to unmarshal success result: %v", err)
	}

	if !decoded.Success {
		t.Fatal("Success flag was not properly serialized")
	}

	if decoded.Data != "test data" {
		t.Fatalf("Expected data 'test data' but got '%v'", decoded.Data)
	}

	// 测试失败的执行结果
	errorResult := ExecutionResult{
		Success: false,
		Error:   "test error",
	}

	// 序列化结果
	errorJSON, err := json.Marshal(errorResult)
	if err != nil {
		t.Fatalf("Failed to marshal error result: %v", err)
	}

	// 验证序列化结果
	if err := json.Unmarshal(errorJSON, &decoded); err != nil {
		t.Fatalf("Failed to unmarshal error result: %v", err)
	}

	if decoded.Success {
		t.Fatal("Success flag was not properly serialized for error result")
	}

	if decoded.Error != "test error" {
		t.Fatalf("Expected error 'test error' but got '%s'", decoded.Error)
	}
}

// 测试当前函数设置
func TestCurrentFunction(t *testing.T) {
	// 保存原始值
	origCurrentFunction := currentFunction
	defer func() { currentFunction = origCurrentFunction }()

	// 设置测试值
	testFuncName := "TestFunction"
	setCurrentFunction(testFuncName)

	// 验证值已设置
	if getCurrentFunction() != testFuncName {
		t.Fatalf("Current function not set correctly, expected '%s' but got '%s'", testFuncName, getCurrentFunction())
	}

	// 清除值
	setCurrentFunction("")

	// 验证值已清除
	if getCurrentFunction() != "" {
		t.Fatalf("Current function not cleared, got '%s'", getCurrentFunction())
	}
}

// 测试上下文方法
func TestContextMethods(t *testing.T) {
	// 设置测试环境
	setupTestEnvironment()

	// 创建上下文
	ctx := &Context{}

	// 测试 Sender
	sender := ctx.Sender()
	if !bytes.Equal(sender[:], mockSender[:]) {
		t.Fatalf("Expected sender %v but got %v", mockSender, sender)
	}

	// 测试 ContractAddress
	contractAddr := ctx.ContractAddress()
	if !bytes.Equal(contractAddr[:], mockContractAddr[:]) {
		t.Fatalf("Expected contract address %v but got %v", mockContractAddr, contractAddr)
	}

	// 测试 BlockHeight
	height := ctx.BlockHeight()
	if height != uint64(mockBlockHeight) {
		t.Fatalf("Expected block height %d but got %d", mockBlockHeight, height)
	}

	// 测试 BlockTime
	blockTime := ctx.BlockTime()
	if blockTime != mockBlockTime {
		t.Fatalf("Expected block time %d but got %d", mockBlockTime, blockTime)
	}

	// 测试 Balance
	balance := ctx.Balance(mockSender)
	if balance != mockBalance {
		t.Fatalf("Expected balance %d but got %d", mockBalance, balance)
	}

	// 测试 Transfer
	err := ctx.Transfer(mockObjectOwner, 100)
	if err != nil {
		t.Fatalf("Transfer failed: %v", err)
	}

	// 验证最后一次调用的函数是 FuncTransfer
	if lastHostFuncID != FuncTransfer {
		t.Fatalf("Expected FuncTransfer but got %d", lastHostFuncID)
	}

	// 测试日志记录
	ctx.Log("TestEvent", "key1", "value1", "key2", 123)

	// 验证最后一次调用的函数是 FuncLog
	if lastHostFuncID != FuncLog {
		t.Fatalf("Expected FuncLog but got %d", lastHostFuncID)
	}
}

// 测试对象操作
func TestObjectOperations(t *testing.T) {
	// 设置测试环境
	setupTestEnvironment()

	// 创建上下文
	ctx := &Context{}

	// 测试 CreateObject
	obj := ctx.CreateObject()
	if obj == nil {
		t.Fatal("CreateObject returned nil")
	}

	// 测试 GetObject - 不使用返回值，只验证操作成功
	_, err := ctx.GetObject(mockObjectID)
	if err != nil {
		t.Fatalf("GetObject failed: %v", err)
	}

	// 测试 Owner
	owner := obj.Owner()
	if !bytes.Equal(owner[:], mockObjectOwner[:]) {
		t.Fatalf("Expected owner %v but got %v", mockObjectOwner, owner)
	}

	// 测试 SetOwner
	obj.SetOwner(mockSender)

	// 验证最后一次调用的函数是 FuncSetObjectOwner
	if lastHostFuncID != FuncSetObjectOwner {
		t.Fatalf("Expected FuncSetObjectOwner but got %d", lastHostFuncID)
	}

	// 测试 Get 字段
	var fieldValue struct {
		Value int `json:"value"`
	}
	err = obj.Get("test", &fieldValue)
	if err != nil {
		t.Fatalf("Get field failed: %v", err)
	}

	// 验证字段值
	if fieldValue.Value != 123 {
		t.Fatalf("Expected field value 123 but got %d", fieldValue.Value)
	}

	// 测试 Set 字段
	err = obj.Set("test", 456)
	if err != nil {
		t.Fatalf("Set field failed: %v", err)
	}

	// 验证最后一次调用的函数是 FuncSetObjectField
	if lastHostFuncID != FuncSetObjectField {
		t.Fatalf("Expected FuncSetObjectField but got %d", lastHostFuncID)
	}
}

// 测试跨合约调用
func TestCrossContractCall(t *testing.T) {
	// 设置测试环境
	setupTestEnvironment()

	// 创建上下文
	ctx := &Context{}

	// 设置当前函数名，用于跨合约调用记录
	origCurrentFunction := currentFunction
	defer func() { currentFunction = origCurrentFunction }()
	setCurrentFunction("TestCaller")

	// 执行跨合约调用
	result, err := ctx.Call(mockObjectOwner, "TestFunction", 123, "abc")
	if err != nil {
		t.Fatalf("Call failed: %v", err)
	}

	// 验证结果
	if !bytes.Equal(result, mockContractResult) {
		t.Fatalf("Expected result %v but got %v", mockContractResult, result)
	}

	// 验证最后一次调用的函数是 FuncCall
	if lastHostFuncID != FuncCall {
		t.Fatalf("Expected FuncCall but got %d", lastHostFuncID)
	}
}

// 测试 mock 模块集成
func TestMockIntegration(t *testing.T) {
	// 设置测试环境
	setupTestEnvironment()

	// 清理 mock 数据
	mock.ClearAll()

	// 准备测试
	ctx := &Context{}
	contractAddr := ctx.ContractAddress()
	functionName := "TestFunction"

	// 记录函数进入
	mock.Enter(contractAddr[:], functionName)

	// 验证记录的调用信息
	callInfo := mock.GetCallInfo()
	if len(callInfo) == 0 {
		t.Fatal("No call information recorded")
	}

	// 记录函数退出
	mock.Exit(contractAddr[:], functionName)

	// 记录跨合约调用
	targetAddr := mockObjectOwner
	mock.RecordCrossContractCall(contractAddr[:], functionName, targetAddr[:], "TargetFunction")

	// 记录错误
	errMsg := "Test error"
	mock.RecordError(contractAddr[:], functionName, errMsg)
}
